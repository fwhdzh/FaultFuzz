相比于CrashFuzz，FaultFuzz做了如下改进：
## 不确定性控制
CrashFuzz只根据I/O点出现的次数来对系统行为进行控制。考虑以下例子。

| A | B | 
| :-------: | :-------: | 
| write(B, 1) |  |
| | read(A, 1) |
| | write(disk, log) |
| write(B, 2) |  |
|  | read(A, 2) |

其中write(disk, log)是系统定期向硬盘中写入日志的操作。

假设我们不进行任何非确定性控制，当我们让系统重新再运行一次时，其可能变为

| A | B | 
| :-------: | :-------: | 
| write(B, 1) |  |
| | write(disk, log) |
| | read(A, 1) |
| write(B, 2) |  |
|  | read(A, 2) |

显然，上面的两个例子代表了两个不同的系统运行场景，如果我们都在read(A, 1)处对B节点注入宕机故障，我们很可能观测到不同的系统恢复行为。

由于CrashFuzz并不对待测系统进行确定性控制，因此它无法保证在测试中系统会按照场景1还是场景2运行。也就是说，如果CrashFuzz在一轮测试中想测试场景1，其只能寄希望于系统刚好随机地表现出了场景1。

在FaultFuzz中，我们实现了确定性控制功能。如果FaultFuzz想要测试场景1，其会通过插装待测系统，使得待测系统在每一个I/O点上等待控制器回应应该继续执行还是等待。由此，FaultFuzz可以控制B节点的write(disk, log)一定会在read(A, 1)之后执行。

需要注意的是，FaultFuzz的确定性控制并不能保证完美处理所有不确定性。分布式系统的不确定性控制一直是一个难以解决的问题。FaultFuzz提供了DETERMINE_WAIT_TIME参数，指示FaultFuzz不确定性控制的最长等待时间。当一个预期的I/O点在最长等待时间内一直没有出现时，FaultFuzz会放弃对当前测试的不确定性控制。

## 新的故障类型：网络断开和恢复

## 使用注解和API插装自己的分布式系统

## 支持多个Workload

## 用户界面